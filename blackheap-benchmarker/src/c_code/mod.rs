// needed for autogenerated code by bindgen
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

mod benchmarker;

use std::ffi::CString;

use benchmarker::{access_pattern_ACCESS_PATTERN_SEQUENTIAL, benchmark_config, error_codes_ERROR_CODES_SUCCESS};

fn run_benchmark() {
    let filepath = CString::new("/tmp/test_file.bin").expect("CString::new failed");
    let config = benchmark_config {
        filepath: filepath.as_ptr(),
        memory_buffer_in_bytes: 1024,
        file_size_in_bytes: 1024 * 10,
        access_size_in_bytes: 128,
        number_of_io_op_tests: 10,
        access_pattern_in_memory: access_pattern_ACCESS_PATTERN_SEQUENTIAL,
        access_pattern_in_file: access_pattern_ACCESS_PATTERN_SEQUENTIAL,
        is_read_operation: true,
        prepare_file_size: true,
        drop_cache_first: false,
        do_reread: false,
        restrict_free_ram_to: 0,
    };

    unsafe {
        let results = benchmarker::benchmark_file(&config);

        if results.res == error_codes_ERROR_CODES_SUCCESS {
            println!("Benchmark completed successfully.");
            println!("Results length: {}", results.length);

            // Access the durations array
            let durations_slice = std::slice::from_raw_parts(results.durations, results.length);
            for (i, &duration) in durations_slice.iter().enumerate() {
                println!("Duration for operation {}: {} seconds", i, duration);
            }

            // Free the durations array allocated by the C code
            libc::free(results.durations as *mut libc::c_void);
        } else {
            println!("Benchmark failed with error code: {:?}", results.res);
        }
    }
}

